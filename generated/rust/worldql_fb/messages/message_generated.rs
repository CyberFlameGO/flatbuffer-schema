// automatically generated by the FlatBuffers compiler, do not modify
extern crate flatbuffers;
use std::mem;
use std::cmp::Ordering;
use self::flatbuffers::{EndianScalar, Follow};
use super::*;
pub enum MessageOffset {}
#[derive(Copy, Clone, PartialEq)]

pub struct Message<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Message<'a> {
  type Inner = Message<'a>;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    Self { _tab: flatbuffers::Table { buf, loc } }
  }
}

impl<'a> Message<'a> {
  pub const VT_INSTRUCTION: flatbuffers::VOffsetT = 4;
  pub const VT_PARAMETER: flatbuffers::VOffsetT = 6;
  pub const VT_SENDER_UUID: flatbuffers::VOffsetT = 8;
  pub const VT_WORLD_NAME: flatbuffers::VOffsetT = 10;
  pub const VT_RECORDS: flatbuffers::VOffsetT = 12;
  pub const VT_ENTITIES: flatbuffers::VOffsetT = 14;
  pub const VT_POSITION: flatbuffers::VOffsetT = 16;
  pub const VT_FLEX: flatbuffers::VOffsetT = 18;

  #[inline]
  pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
    Message { _tab: table }
  }
  #[allow(unused_mut)]
  pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
    _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
    args: &'args MessageArgs<'args>
  ) -> flatbuffers::WIPOffset<Message<'bldr>> {
    let mut builder = MessageBuilder::new(_fbb);
    if let Some(x) = args.flex { builder.add_flex(x); }
    if let Some(x) = args.position { builder.add_position(x); }
    if let Some(x) = args.entities { builder.add_entities(x); }
    if let Some(x) = args.records { builder.add_records(x); }
    if let Some(x) = args.world_name { builder.add_world_name(x); }
    if let Some(x) = args.sender_uuid { builder.add_sender_uuid(x); }
    if let Some(x) = args.parameter { builder.add_parameter(x); }
    builder.add_instruction(args.instruction);
    builder.finish()
  }

  pub fn unpack(&self) -> MessageT {
    let instruction = self.instruction();
    let parameter = self.parameter().map(|x| {
      x.to_string()
    });
    let sender_uuid = self.sender_uuid().map(|x| {
      x.to_string()
    });
    let world_name = self.world_name().map(|x| {
      x.to_string()
    });
    let records = self.records().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let entities = self.entities().map(|x| {
      x.iter().map(|t| t.unpack()).collect()
    });
    let position = self.position().map(|x| {
      x.unpack()
    });
    let flex = self.flex().map(|x| {
      x.to_vec()
    });
    MessageT {
      instruction,
      parameter,
      sender_uuid,
      world_name,
      records,
      entities,
      position,
      flex,
    }
  }

  #[inline]
  pub fn instruction(&self) -> Instruction {
    self._tab.get::<Instruction>(Message::VT_INSTRUCTION, Some(Instruction::Heartbeat)).unwrap()
  }
  #[inline]
  pub fn parameter(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Message::VT_PARAMETER, None)
  }
  #[inline]
  pub fn sender_uuid(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Message::VT_SENDER_UUID, None)
  }
  #[inline]
  pub fn world_name(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Message::VT_WORLD_NAME, None)
  }
  #[inline]
  pub fn records(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Record<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Record>>>>(Message::VT_RECORDS, None)
  }
  #[inline]
  pub fn entities(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Entity<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Entity>>>>(Message::VT_ENTITIES, None)
  }
  #[inline]
  pub fn position(&self) -> Option<&'a Vec3d> {
    self._tab.get::<Vec3d>(Message::VT_POSITION, None)
  }
  #[inline]
  pub fn flex(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Message::VT_FLEX, None).map(|v| v.safe_slice())
  }
}

impl flatbuffers::Verifiable for Message<'_> {
  #[inline]
  fn run_verifier(
    v: &mut flatbuffers::Verifier, pos: usize
  ) -> Result<(), flatbuffers::InvalidFlatbuffer> {
    use self::flatbuffers::Verifiable;
    v.visit_table(pos)?
     .visit_field::<Instruction>("instruction", Self::VT_INSTRUCTION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("parameter", Self::VT_PARAMETER, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("sender_uuid", Self::VT_SENDER_UUID, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<&str>>("world_name", Self::VT_WORLD_NAME, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Record>>>>("records", Self::VT_RECORDS, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, flatbuffers::ForwardsUOffset<Entity>>>>("entities", Self::VT_ENTITIES, false)?
     .visit_field::<Vec3d>("position", Self::VT_POSITION, false)?
     .visit_field::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'_, u8>>>("flex", Self::VT_FLEX, false)?
     .finish();
    Ok(())
  }
}
pub struct MessageArgs<'a> {
    pub instruction: Instruction,
    pub parameter: Option<flatbuffers::WIPOffset<&'a str>>,
    pub sender_uuid: Option<flatbuffers::WIPOffset<&'a str>>,
    pub world_name: Option<flatbuffers::WIPOffset<&'a str>>,
    pub records: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Record<'a>>>>>,
    pub entities: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Entity<'a>>>>>,
    pub position: Option<&'a Vec3d>,
    pub flex: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a, u8>>>,
}
impl<'a> Default for MessageArgs<'a> {
  #[inline]
  fn default() -> Self {
    MessageArgs {
      instruction: Instruction::Heartbeat,
      parameter: None,
      sender_uuid: None,
      world_name: None,
      records: None,
      entities: None,
      position: None,
      flex: None,
    }
  }
}
pub struct MessageBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> MessageBuilder<'a, 'b> {
  #[inline]
  pub fn add_instruction(&mut self, instruction: Instruction) {
    self.fbb_.push_slot::<Instruction>(Message::VT_INSTRUCTION, instruction, Instruction::Heartbeat);
  }
  #[inline]
  pub fn add_parameter(&mut self, parameter: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Message::VT_PARAMETER, parameter);
  }
  #[inline]
  pub fn add_sender_uuid(&mut self, sender_uuid: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Message::VT_SENDER_UUID, sender_uuid);
  }
  #[inline]
  pub fn add_world_name(&mut self, world_name: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Message::VT_WORLD_NAME, world_name);
  }
  #[inline]
  pub fn add_records(&mut self, records: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Record<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Message::VT_RECORDS, records);
  }
  #[inline]
  pub fn add_entities(&mut self, entities: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Entity<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Message::VT_ENTITIES, entities);
  }
  #[inline]
  pub fn add_position(&mut self, position: &Vec3d) {
    self.fbb_.push_slot_always::<&Vec3d>(Message::VT_POSITION, position);
  }
  #[inline]
  pub fn add_flex(&mut self, flex: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Message::VT_FLEX, flex);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> MessageBuilder<'a, 'b> {
    let start = _fbb.start_table();
    MessageBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Message<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

impl std::fmt::Debug for Message<'_> {
  fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
    let mut ds = f.debug_struct("Message");
      ds.field("instruction", &self.instruction());
      ds.field("parameter", &self.parameter());
      ds.field("sender_uuid", &self.sender_uuid());
      ds.field("world_name", &self.world_name());
      ds.field("records", &self.records());
      ds.field("entities", &self.entities());
      ds.field("position", &self.position());
      ds.field("flex", &self.flex());
      ds.finish()
  }
}
#[non_exhaustive]
#[derive(Debug, Clone, PartialEq)]
pub struct MessageT {
  pub instruction: Instruction,
  pub parameter: Option<String>,
  pub sender_uuid: Option<String>,
  pub world_name: Option<String>,
  pub records: Option<Vec<RecordT>>,
  pub entities: Option<Vec<EntityT>>,
  pub position: Option<Vec3dT>,
  pub flex: Option<Vec<u8>>,
}
impl Default for MessageT {
  fn default() -> Self {
    Self {
      instruction: Instruction::Heartbeat,
      parameter: None,
      sender_uuid: None,
      world_name: None,
      records: None,
      entities: None,
      position: None,
      flex: None,
    }
  }
}
impl MessageT {
  pub fn pack<'b>(
    &self,
    _fbb: &mut flatbuffers::FlatBufferBuilder<'b>
  ) -> flatbuffers::WIPOffset<Message<'b>> {
    let instruction = self.instruction;
    let parameter = self.parameter.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let sender_uuid = self.sender_uuid.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let world_name = self.world_name.as_ref().map(|x|{
      _fbb.create_string(x)
    });
    let records = self.records.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let entities = self.entities.as_ref().map(|x|{
      let w: Vec<_> = x.iter().map(|t| t.pack(_fbb)).collect();_fbb.create_vector(&w)
    });
    let position_tmp = self.position.as_ref().map(|x| x.pack());
    let position = position_tmp.as_ref();
    let flex = self.flex.as_ref().map(|x|{
      _fbb.create_vector(x)
    });
    Message::create(_fbb, &MessageArgs{
      instruction,
      parameter,
      sender_uuid,
      world_name,
      records,
      entities,
      position,
      flex,
    })
  }
}
#[inline]
#[deprecated(since="2.0.0", note="Deprecated in favor of `root_as...` methods.")]
pub fn get_root_as_message<'a>(buf: &'a [u8]) -> Message<'a> {
  unsafe { flatbuffers::root_unchecked::<Message<'a>>(buf) }
}

#[inline]
#[deprecated(since="2.0.0", note="Deprecated in favor of `root_as...` methods.")]
pub fn get_size_prefixed_root_as_message<'a>(buf: &'a [u8]) -> Message<'a> {
  unsafe { flatbuffers::size_prefixed_root_unchecked::<Message<'a>>(buf) }
}

#[inline]
/// Verifies that a buffer of bytes contains a `Message`
/// and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_message_unchecked`.
pub fn root_as_message(buf: &[u8]) -> Result<Message, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root::<Message>(buf)
}
#[inline]
/// Verifies that a buffer of bytes contains a size prefixed
/// `Message` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `size_prefixed_root_as_message_unchecked`.
pub fn size_prefixed_root_as_message(buf: &[u8]) -> Result<Message, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root::<Message>(buf)
}
#[inline]
/// Verifies, with the given options, that a buffer of bytes
/// contains a `Message` and returns it.
/// Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_message_unchecked`.
pub fn root_as_message_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Message<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::root_with_opts::<Message<'b>>(opts, buf)
}
#[inline]
/// Verifies, with the given verifier options, that a buffer of
/// bytes contains a size prefixed `Message` and returns
/// it. Note that verification is still experimental and may not
/// catch every error, or be maximally performant. For the
/// previous, unchecked, behavior use
/// `root_as_message_unchecked`.
pub fn size_prefixed_root_as_message_with_opts<'b, 'o>(
  opts: &'o flatbuffers::VerifierOptions,
  buf: &'b [u8],
) -> Result<Message<'b>, flatbuffers::InvalidFlatbuffer> {
  flatbuffers::size_prefixed_root_with_opts::<Message<'b>>(opts, buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a Message and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid `Message`.
pub unsafe fn root_as_message_unchecked(buf: &[u8]) -> Message {
  flatbuffers::root_unchecked::<Message>(buf)
}
#[inline]
/// Assumes, without verification, that a buffer of bytes contains a size prefixed Message and returns it.
/// # Safety
/// Callers must trust the given bytes do indeed contain a valid size prefixed `Message`.
pub unsafe fn size_prefixed_root_as_message_unchecked(buf: &[u8]) -> Message {
  flatbuffers::size_prefixed_root_unchecked::<Message>(buf)
}
#[inline]
pub fn finish_message_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<Message<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_message_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<Message<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
