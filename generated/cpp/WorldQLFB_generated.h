// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_WORLDQLFB_WORLDQLFB_MESSAGES_H_
#define FLATBUFFERS_GENERATED_WORLDQLFB_WORLDQLFB_MESSAGES_H_

#include "flatbuffers/flatbuffers.h"

namespace WorldqlFb {
namespace Messages {

struct Vec3d;

struct Record;
struct RecordBuilder;
struct RecordT;

struct Entity;
struct EntityBuilder;
struct EntityT;

struct Message;
struct MessageBuilder;
struct MessageT;

enum Instruction : uint8_t {
  Instruction_Heartbeat = 0,
  Instruction_Handshake = 1,
  Instruction_LocalMessage = 2,
  Instruction_GlobalMessage = 3,
  Instruction_RecordCreate = 4,
  Instruction_RecordRead = 5,
  Instruction_RecordUpdate = 6,
  Instruction_RecordDelete = 7,
  Instruction_RecordReply = 8,
  Instruction_AreaSubscribe = 9,
  Instruction_AreaUnsubscribe = 10,
  Instruction_Unknown = 255,
  Instruction_MIN = Instruction_Heartbeat,
  Instruction_MAX = Instruction_Unknown
};

inline const Instruction (&EnumValuesInstruction())[12] {
  static const Instruction values[] = {
    Instruction_Heartbeat,
    Instruction_Handshake,
    Instruction_LocalMessage,
    Instruction_GlobalMessage,
    Instruction_RecordCreate,
    Instruction_RecordRead,
    Instruction_RecordUpdate,
    Instruction_RecordDelete,
    Instruction_RecordReply,
    Instruction_AreaSubscribe,
    Instruction_AreaUnsubscribe,
    Instruction_Unknown
  };
  return values;
}

inline const char *EnumNameInstruction(Instruction e) {
  switch (e) {
    case Instruction_Heartbeat: return "Heartbeat";
    case Instruction_Handshake: return "Handshake";
    case Instruction_LocalMessage: return "LocalMessage";
    case Instruction_GlobalMessage: return "GlobalMessage";
    case Instruction_RecordCreate: return "RecordCreate";
    case Instruction_RecordRead: return "RecordRead";
    case Instruction_RecordUpdate: return "RecordUpdate";
    case Instruction_RecordDelete: return "RecordDelete";
    case Instruction_RecordReply: return "RecordReply";
    case Instruction_AreaSubscribe: return "AreaSubscribe";
    case Instruction_AreaUnsubscribe: return "AreaUnsubscribe";
    case Instruction_Unknown: return "Unknown";
    default: return "";
  }
}

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) Vec3d FLATBUFFERS_FINAL_CLASS {
 private:
  double x_;
  double y_;
  double z_;

 public:
  Vec3d()
      : x_(0),
        y_(0),
        z_(0) {
  }
  Vec3d(double _x, double _y, double _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  double x() const {
    return flatbuffers::EndianScalar(x_);
  }
  double y() const {
    return flatbuffers::EndianScalar(y_);
  }
  double z() const {
    return flatbuffers::EndianScalar(z_);
  }
};
FLATBUFFERS_STRUCT_END(Vec3d, 24);

struct RecordT : public flatbuffers::NativeTable {
  typedef Record TableType;
  std::string uuid{};
  std::unique_ptr<WorldqlFb::Messages::Vec3d> position{};
  std::string world_name{};
  std::string data{};
  std::vector<uint8_t> flex{};
};

struct Record FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RecordT NativeTableType;
  typedef RecordBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UUID = 4,
    VT_POSITION = 6,
    VT_WORLD_NAME = 8,
    VT_DATA = 10,
    VT_FLEX = 12
  };
  const flatbuffers::String *uuid() const {
    return GetPointer<const flatbuffers::String *>(VT_UUID);
  }
  const WorldqlFb::Messages::Vec3d *position() const {
    return GetStruct<const WorldqlFb::Messages::Vec3d *>(VT_POSITION);
  }
  const flatbuffers::String *world_name() const {
    return GetPointer<const flatbuffers::String *>(VT_WORLD_NAME);
  }
  const flatbuffers::String *data() const {
    return GetPointer<const flatbuffers::String *>(VT_DATA);
  }
  const flatbuffers::Vector<uint8_t> *flex() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_FLEX);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_UUID) &&
           verifier.VerifyString(uuid()) &&
           VerifyField<WorldqlFb::Messages::Vec3d>(verifier, VT_POSITION) &&
           VerifyOffset(verifier, VT_WORLD_NAME) &&
           verifier.VerifyString(world_name()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyString(data()) &&
           VerifyOffset(verifier, VT_FLEX) &&
           verifier.VerifyVector(flex()) &&
           verifier.EndTable();
  }
  RecordT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(RecordT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Record> Pack(flatbuffers::FlatBufferBuilder &_fbb, const RecordT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct RecordBuilder {
  typedef Record Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_uuid(flatbuffers::Offset<flatbuffers::String> uuid) {
    fbb_.AddOffset(Record::VT_UUID, uuid);
  }
  void add_position(const WorldqlFb::Messages::Vec3d *position) {
    fbb_.AddStruct(Record::VT_POSITION, position);
  }
  void add_world_name(flatbuffers::Offset<flatbuffers::String> world_name) {
    fbb_.AddOffset(Record::VT_WORLD_NAME, world_name);
  }
  void add_data(flatbuffers::Offset<flatbuffers::String> data) {
    fbb_.AddOffset(Record::VT_DATA, data);
  }
  void add_flex(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> flex) {
    fbb_.AddOffset(Record::VT_FLEX, flex);
  }
  explicit RecordBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Record> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Record>(end);
    return o;
  }
};

inline flatbuffers::Offset<Record> CreateRecord(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> uuid = 0,
    const WorldqlFb::Messages::Vec3d *position = 0,
    flatbuffers::Offset<flatbuffers::String> world_name = 0,
    flatbuffers::Offset<flatbuffers::String> data = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> flex = 0) {
  RecordBuilder builder_(_fbb);
  builder_.add_flex(flex);
  builder_.add_data(data);
  builder_.add_world_name(world_name);
  builder_.add_position(position);
  builder_.add_uuid(uuid);
  return builder_.Finish();
}

inline flatbuffers::Offset<Record> CreateRecordDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *uuid = nullptr,
    const WorldqlFb::Messages::Vec3d *position = 0,
    const char *world_name = nullptr,
    const char *data = nullptr,
    const std::vector<uint8_t> *flex = nullptr) {
  auto uuid__ = uuid ? _fbb.CreateString(uuid) : 0;
  auto world_name__ = world_name ? _fbb.CreateString(world_name) : 0;
  auto data__ = data ? _fbb.CreateString(data) : 0;
  auto flex__ = flex ? _fbb.CreateVector<uint8_t>(*flex) : 0;
  return WorldqlFb::Messages::CreateRecord(
      _fbb,
      uuid__,
      position,
      world_name__,
      data__,
      flex__);
}

flatbuffers::Offset<Record> CreateRecord(flatbuffers::FlatBufferBuilder &_fbb, const RecordT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct EntityT : public flatbuffers::NativeTable {
  typedef Entity TableType;
  std::string uuid{};
  std::unique_ptr<WorldqlFb::Messages::Vec3d> position{};
  std::string world_name{};
  std::string data{};
  std::vector<uint8_t> flex{};
};

struct Entity FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef EntityT NativeTableType;
  typedef EntityBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UUID = 4,
    VT_POSITION = 6,
    VT_WORLD_NAME = 8,
    VT_DATA = 10,
    VT_FLEX = 12
  };
  const flatbuffers::String *uuid() const {
    return GetPointer<const flatbuffers::String *>(VT_UUID);
  }
  const WorldqlFb::Messages::Vec3d *position() const {
    return GetStruct<const WorldqlFb::Messages::Vec3d *>(VT_POSITION);
  }
  const flatbuffers::String *world_name() const {
    return GetPointer<const flatbuffers::String *>(VT_WORLD_NAME);
  }
  const flatbuffers::String *data() const {
    return GetPointer<const flatbuffers::String *>(VT_DATA);
  }
  const flatbuffers::Vector<uint8_t> *flex() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_FLEX);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_UUID) &&
           verifier.VerifyString(uuid()) &&
           VerifyField<WorldqlFb::Messages::Vec3d>(verifier, VT_POSITION) &&
           VerifyOffset(verifier, VT_WORLD_NAME) &&
           verifier.VerifyString(world_name()) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyString(data()) &&
           VerifyOffset(verifier, VT_FLEX) &&
           verifier.VerifyVector(flex()) &&
           verifier.EndTable();
  }
  EntityT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(EntityT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Entity> Pack(flatbuffers::FlatBufferBuilder &_fbb, const EntityT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct EntityBuilder {
  typedef Entity Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_uuid(flatbuffers::Offset<flatbuffers::String> uuid) {
    fbb_.AddOffset(Entity::VT_UUID, uuid);
  }
  void add_position(const WorldqlFb::Messages::Vec3d *position) {
    fbb_.AddStruct(Entity::VT_POSITION, position);
  }
  void add_world_name(flatbuffers::Offset<flatbuffers::String> world_name) {
    fbb_.AddOffset(Entity::VT_WORLD_NAME, world_name);
  }
  void add_data(flatbuffers::Offset<flatbuffers::String> data) {
    fbb_.AddOffset(Entity::VT_DATA, data);
  }
  void add_flex(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> flex) {
    fbb_.AddOffset(Entity::VT_FLEX, flex);
  }
  explicit EntityBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Entity> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Entity>(end);
    return o;
  }
};

inline flatbuffers::Offset<Entity> CreateEntity(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> uuid = 0,
    const WorldqlFb::Messages::Vec3d *position = 0,
    flatbuffers::Offset<flatbuffers::String> world_name = 0,
    flatbuffers::Offset<flatbuffers::String> data = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> flex = 0) {
  EntityBuilder builder_(_fbb);
  builder_.add_flex(flex);
  builder_.add_data(data);
  builder_.add_world_name(world_name);
  builder_.add_position(position);
  builder_.add_uuid(uuid);
  return builder_.Finish();
}

inline flatbuffers::Offset<Entity> CreateEntityDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *uuid = nullptr,
    const WorldqlFb::Messages::Vec3d *position = 0,
    const char *world_name = nullptr,
    const char *data = nullptr,
    const std::vector<uint8_t> *flex = nullptr) {
  auto uuid__ = uuid ? _fbb.CreateString(uuid) : 0;
  auto world_name__ = world_name ? _fbb.CreateString(world_name) : 0;
  auto data__ = data ? _fbb.CreateString(data) : 0;
  auto flex__ = flex ? _fbb.CreateVector<uint8_t>(*flex) : 0;
  return WorldqlFb::Messages::CreateEntity(
      _fbb,
      uuid__,
      position,
      world_name__,
      data__,
      flex__);
}

flatbuffers::Offset<Entity> CreateEntity(flatbuffers::FlatBufferBuilder &_fbb, const EntityT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MessageT : public flatbuffers::NativeTable {
  typedef Message TableType;
  WorldqlFb::Messages::Instruction instruction = WorldqlFb::Messages::Instruction_Heartbeat;
  std::string parameter{};
  std::string sender_uuid{};
  std::string world_name{};
  std::vector<std::unique_ptr<WorldqlFb::Messages::RecordT>> records{};
  std::vector<std::unique_ptr<WorldqlFb::Messages::EntityT>> entities{};
  std::unique_ptr<WorldqlFb::Messages::Vec3d> position{};
  std::vector<uint8_t> flex{};
};

struct Message FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MessageT NativeTableType;
  typedef MessageBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INSTRUCTION = 4,
    VT_PARAMETER = 6,
    VT_SENDER_UUID = 8,
    VT_WORLD_NAME = 10,
    VT_RECORDS = 12,
    VT_ENTITIES = 14,
    VT_POSITION = 16,
    VT_FLEX = 18
  };
  WorldqlFb::Messages::Instruction instruction() const {
    return static_cast<WorldqlFb::Messages::Instruction>(GetField<uint8_t>(VT_INSTRUCTION, 0));
  }
  const flatbuffers::String *parameter() const {
    return GetPointer<const flatbuffers::String *>(VT_PARAMETER);
  }
  const flatbuffers::String *sender_uuid() const {
    return GetPointer<const flatbuffers::String *>(VT_SENDER_UUID);
  }
  const flatbuffers::String *world_name() const {
    return GetPointer<const flatbuffers::String *>(VT_WORLD_NAME);
  }
  const flatbuffers::Vector<flatbuffers::Offset<WorldqlFb::Messages::Record>> *records() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<WorldqlFb::Messages::Record>> *>(VT_RECORDS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<WorldqlFb::Messages::Entity>> *entities() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<WorldqlFb::Messages::Entity>> *>(VT_ENTITIES);
  }
  const WorldqlFb::Messages::Vec3d *position() const {
    return GetStruct<const WorldqlFb::Messages::Vec3d *>(VT_POSITION);
  }
  const flatbuffers::Vector<uint8_t> *flex() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_FLEX);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_INSTRUCTION) &&
           VerifyOffset(verifier, VT_PARAMETER) &&
           verifier.VerifyString(parameter()) &&
           VerifyOffset(verifier, VT_SENDER_UUID) &&
           verifier.VerifyString(sender_uuid()) &&
           VerifyOffset(verifier, VT_WORLD_NAME) &&
           verifier.VerifyString(world_name()) &&
           VerifyOffset(verifier, VT_RECORDS) &&
           verifier.VerifyVector(records()) &&
           verifier.VerifyVectorOfTables(records()) &&
           VerifyOffset(verifier, VT_ENTITIES) &&
           verifier.VerifyVector(entities()) &&
           verifier.VerifyVectorOfTables(entities()) &&
           VerifyField<WorldqlFb::Messages::Vec3d>(verifier, VT_POSITION) &&
           VerifyOffset(verifier, VT_FLEX) &&
           verifier.VerifyVector(flex()) &&
           verifier.EndTable();
  }
  MessageT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MessageT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<Message> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MessageT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MessageBuilder {
  typedef Message Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_instruction(WorldqlFb::Messages::Instruction instruction) {
    fbb_.AddElement<uint8_t>(Message::VT_INSTRUCTION, static_cast<uint8_t>(instruction), 0);
  }
  void add_parameter(flatbuffers::Offset<flatbuffers::String> parameter) {
    fbb_.AddOffset(Message::VT_PARAMETER, parameter);
  }
  void add_sender_uuid(flatbuffers::Offset<flatbuffers::String> sender_uuid) {
    fbb_.AddOffset(Message::VT_SENDER_UUID, sender_uuid);
  }
  void add_world_name(flatbuffers::Offset<flatbuffers::String> world_name) {
    fbb_.AddOffset(Message::VT_WORLD_NAME, world_name);
  }
  void add_records(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<WorldqlFb::Messages::Record>>> records) {
    fbb_.AddOffset(Message::VT_RECORDS, records);
  }
  void add_entities(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<WorldqlFb::Messages::Entity>>> entities) {
    fbb_.AddOffset(Message::VT_ENTITIES, entities);
  }
  void add_position(const WorldqlFb::Messages::Vec3d *position) {
    fbb_.AddStruct(Message::VT_POSITION, position);
  }
  void add_flex(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> flex) {
    fbb_.AddOffset(Message::VT_FLEX, flex);
  }
  explicit MessageBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Message> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Message>(end);
    return o;
  }
};

inline flatbuffers::Offset<Message> CreateMessage(
    flatbuffers::FlatBufferBuilder &_fbb,
    WorldqlFb::Messages::Instruction instruction = WorldqlFb::Messages::Instruction_Heartbeat,
    flatbuffers::Offset<flatbuffers::String> parameter = 0,
    flatbuffers::Offset<flatbuffers::String> sender_uuid = 0,
    flatbuffers::Offset<flatbuffers::String> world_name = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<WorldqlFb::Messages::Record>>> records = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<WorldqlFb::Messages::Entity>>> entities = 0,
    const WorldqlFb::Messages::Vec3d *position = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> flex = 0) {
  MessageBuilder builder_(_fbb);
  builder_.add_flex(flex);
  builder_.add_position(position);
  builder_.add_entities(entities);
  builder_.add_records(records);
  builder_.add_world_name(world_name);
  builder_.add_sender_uuid(sender_uuid);
  builder_.add_parameter(parameter);
  builder_.add_instruction(instruction);
  return builder_.Finish();
}

inline flatbuffers::Offset<Message> CreateMessageDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    WorldqlFb::Messages::Instruction instruction = WorldqlFb::Messages::Instruction_Heartbeat,
    const char *parameter = nullptr,
    const char *sender_uuid = nullptr,
    const char *world_name = nullptr,
    const std::vector<flatbuffers::Offset<WorldqlFb::Messages::Record>> *records = nullptr,
    const std::vector<flatbuffers::Offset<WorldqlFb::Messages::Entity>> *entities = nullptr,
    const WorldqlFb::Messages::Vec3d *position = 0,
    const std::vector<uint8_t> *flex = nullptr) {
  auto parameter__ = parameter ? _fbb.CreateString(parameter) : 0;
  auto sender_uuid__ = sender_uuid ? _fbb.CreateString(sender_uuid) : 0;
  auto world_name__ = world_name ? _fbb.CreateString(world_name) : 0;
  auto records__ = records ? _fbb.CreateVector<flatbuffers::Offset<WorldqlFb::Messages::Record>>(*records) : 0;
  auto entities__ = entities ? _fbb.CreateVector<flatbuffers::Offset<WorldqlFb::Messages::Entity>>(*entities) : 0;
  auto flex__ = flex ? _fbb.CreateVector<uint8_t>(*flex) : 0;
  return WorldqlFb::Messages::CreateMessage(
      _fbb,
      instruction,
      parameter__,
      sender_uuid__,
      world_name__,
      records__,
      entities__,
      position,
      flex__);
}

flatbuffers::Offset<Message> CreateMessage(flatbuffers::FlatBufferBuilder &_fbb, const MessageT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline RecordT *Record::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<RecordT>(new RecordT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Record::UnPackTo(RecordT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = uuid(); if (_e) _o->uuid = _e->str(); }
  { auto _e = position(); if (_e) _o->position = std::unique_ptr<WorldqlFb::Messages::Vec3d>(new WorldqlFb::Messages::Vec3d(*_e)); }
  { auto _e = world_name(); if (_e) _o->world_name = _e->str(); }
  { auto _e = data(); if (_e) _o->data = _e->str(); }
  { auto _e = flex(); if (_e) { _o->flex.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->flex.begin()); } }
}

inline flatbuffers::Offset<Record> Record::Pack(flatbuffers::FlatBufferBuilder &_fbb, const RecordT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateRecord(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Record> CreateRecord(flatbuffers::FlatBufferBuilder &_fbb, const RecordT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const RecordT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _uuid = _o->uuid.empty() ? 0 : _fbb.CreateString(_o->uuid);
  auto _position = _o->position ? _o->position.get() : 0;
  auto _world_name = _o->world_name.empty() ? 0 : _fbb.CreateString(_o->world_name);
  auto _data = _o->data.empty() ? 0 : _fbb.CreateString(_o->data);
  auto _flex = _o->flex.size() ? _fbb.CreateVector(_o->flex) : 0;
  return WorldqlFb::Messages::CreateRecord(
      _fbb,
      _uuid,
      _position,
      _world_name,
      _data,
      _flex);
}

inline EntityT *Entity::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<EntityT>(new EntityT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Entity::UnPackTo(EntityT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = uuid(); if (_e) _o->uuid = _e->str(); }
  { auto _e = position(); if (_e) _o->position = std::unique_ptr<WorldqlFb::Messages::Vec3d>(new WorldqlFb::Messages::Vec3d(*_e)); }
  { auto _e = world_name(); if (_e) _o->world_name = _e->str(); }
  { auto _e = data(); if (_e) _o->data = _e->str(); }
  { auto _e = flex(); if (_e) { _o->flex.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->flex.begin()); } }
}

inline flatbuffers::Offset<Entity> Entity::Pack(flatbuffers::FlatBufferBuilder &_fbb, const EntityT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateEntity(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Entity> CreateEntity(flatbuffers::FlatBufferBuilder &_fbb, const EntityT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const EntityT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _uuid = _o->uuid.empty() ? 0 : _fbb.CreateString(_o->uuid);
  auto _position = _o->position ? _o->position.get() : 0;
  auto _world_name = _o->world_name.empty() ? 0 : _fbb.CreateString(_o->world_name);
  auto _data = _o->data.empty() ? 0 : _fbb.CreateString(_o->data);
  auto _flex = _o->flex.size() ? _fbb.CreateVector(_o->flex) : 0;
  return WorldqlFb::Messages::CreateEntity(
      _fbb,
      _uuid,
      _position,
      _world_name,
      _data,
      _flex);
}

inline MessageT *Message::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MessageT>(new MessageT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void Message::UnPackTo(MessageT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = instruction(); _o->instruction = _e; }
  { auto _e = parameter(); if (_e) _o->parameter = _e->str(); }
  { auto _e = sender_uuid(); if (_e) _o->sender_uuid = _e->str(); }
  { auto _e = world_name(); if (_e) _o->world_name = _e->str(); }
  { auto _e = records(); if (_e) { _o->records.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->records[_i] = std::unique_ptr<WorldqlFb::Messages::RecordT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = entities(); if (_e) { _o->entities.resize(_e->size()); for (flatbuffers::uoffset_t _i = 0; _i < _e->size(); _i++) { _o->entities[_i] = std::unique_ptr<WorldqlFb::Messages::EntityT>(_e->Get(_i)->UnPack(_resolver)); } } }
  { auto _e = position(); if (_e) _o->position = std::unique_ptr<WorldqlFb::Messages::Vec3d>(new WorldqlFb::Messages::Vec3d(*_e)); }
  { auto _e = flex(); if (_e) { _o->flex.resize(_e->size()); std::copy(_e->begin(), _e->end(), _o->flex.begin()); } }
}

inline flatbuffers::Offset<Message> Message::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MessageT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMessage(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<Message> CreateMessage(flatbuffers::FlatBufferBuilder &_fbb, const MessageT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MessageT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _instruction = _o->instruction;
  auto _parameter = _o->parameter.empty() ? 0 : _fbb.CreateString(_o->parameter);
  auto _sender_uuid = _o->sender_uuid.empty() ? 0 : _fbb.CreateString(_o->sender_uuid);
  auto _world_name = _o->world_name.empty() ? 0 : _fbb.CreateString(_o->world_name);
  auto _records = _o->records.size() ? _fbb.CreateVector<flatbuffers::Offset<WorldqlFb::Messages::Record>> (_o->records.size(), [](size_t i, _VectorArgs *__va) { return CreateRecord(*__va->__fbb, __va->__o->records[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _entities = _o->entities.size() ? _fbb.CreateVector<flatbuffers::Offset<WorldqlFb::Messages::Entity>> (_o->entities.size(), [](size_t i, _VectorArgs *__va) { return CreateEntity(*__va->__fbb, __va->__o->entities[i].get(), __va->__rehasher); }, &_va ) : 0;
  auto _position = _o->position ? _o->position.get() : 0;
  auto _flex = _o->flex.size() ? _fbb.CreateVector(_o->flex) : 0;
  return WorldqlFb::Messages::CreateMessage(
      _fbb,
      _instruction,
      _parameter,
      _sender_uuid,
      _world_name,
      _records,
      _entities,
      _position,
      _flex);
}

inline const WorldqlFb::Messages::Message *GetMessage(const void *buf) {
  return flatbuffers::GetRoot<WorldqlFb::Messages::Message>(buf);
}

inline const WorldqlFb::Messages::Message *GetSizePrefixedMessage(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<WorldqlFb::Messages::Message>(buf);
}

inline bool VerifyMessageBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<WorldqlFb::Messages::Message>(nullptr);
}

inline bool VerifySizePrefixedMessageBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<WorldqlFb::Messages::Message>(nullptr);
}

inline void FinishMessageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<WorldqlFb::Messages::Message> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedMessageBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<WorldqlFb::Messages::Message> root) {
  fbb.FinishSizePrefixed(root);
}

inline std::unique_ptr<WorldqlFb::Messages::MessageT> UnPackMessage(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<WorldqlFb::Messages::MessageT>(GetMessage(buf)->UnPack(res));
}

inline std::unique_ptr<WorldqlFb::Messages::MessageT> UnPackSizePrefixedMessage(
    const void *buf,
    const flatbuffers::resolver_function_t *res = nullptr) {
  return std::unique_ptr<WorldqlFb::Messages::MessageT>(GetSizePrefixedMessage(buf)->UnPack(res));
}

}  // namespace Messages
}  // namespace WorldqlFb

#endif  // FLATBUFFERS_GENERATED_WORLDQLFB_WORLDQLFB_MESSAGES_H_
